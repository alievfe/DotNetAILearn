### 使用笔记本

- vscode安装 polyglot notebook

- 打开[semantic-kernel/dotnet/notebooks at main · microsoft/semantic-kernel](https://github.com/microsoft/semantic-kernel/tree/main/dotnet/notebooks)





- 语义插件（Semantic Plugin）是语义函数的集合，其中每个函数都用自然语言定义，自然语言可以通过文本文件提供。



### 术语表

- **语义内核**（Semantic Kernel, SK）- 协调者，它通过SK可用的插件（PLUGINS）来满足用户的请求（ASK）。
- **请求**（Ask）- 用户向语义内核提出的要求，以协助达成用户的目标。
  - “我们向SK提出请求（ASKs）”
- **插件**（Plugins）- 一系列针对特定领域的、经过精细调整的函数集合，作为整体提供给SK使用。
  - “我们有一个用于更好地使用Office的插件”
- **函数**（Function）- 由语义AI和/或原生代码组成的计算单元，存在于某个插件（PLUGIN）中。
  - “Office插件包含许多函数（FUNCTIONS）” 
- **原生函数**（Native Function）- 使用传统编程语言（如C#、Python、TypeScript）表达，并能与SK轻松集成。
- **语义函数**（Semantic Function）- 在文本文件 "skprompt.txt" 中以自然语言表述，采用SK提示模板语言。每个语义函数都由一个独特的提示模板文件定义，这些文件是利用现代提示工程技术开发的。
- **记忆**（Memory）- 一个基于事实、事件、文档的语义知识集合，通过嵌入式索引进行组织。 

> - 内核设计鼓励函数组合，允许用户将多个函数（原生和语义）合并成单一的流水线。

<img src="./01img/221690406-caaff98e-87b5-40b7-9c58-cfa9623789b5.png" alt="image" style="zoom:67%;" />

<img src="./01img/221690156-3f90a8c9-ef90-46f7-a097-beb483656e97.png" alt="image" style="zoom: 67%;" />

config.json

```json
{
  "schema": 1,
  "description": "Generate a funny joke",
  "execution_settings": [
    {
      "max_tokens": 1000,
      "temperature": 0.9,
      "top_p": 0.0,
      "presence_penalty": 0.0,
      "frequency_penalty": 0.0
    }
  ]
}
```



### function calling

- 配置迁移：[Migrating to the new Function Calling capabilities | Microsoft Learn](https://learn.microsoft.com/en-gb/semantic-kernel/support/migration/function-calling-migration-guide?pivots=programming-language-csharp)

```cs
// Before
var executionSettings = new OpenAIPromptExecutionSettings { ToolCallBehavior = ToolCallBehavior.AutoInvokeKernelFunctions };

// After
var executionSettings = new OpenAIPromptExecutionSettings { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto() };
```

- 调用时候还可以通过使用 `IChatCompletionService` 运行它，以访问 `ChatHistory` 对象，以查看哪些函数作为函数调用过程的一部分被调用。注意，需要将 Kernel 作为参数传递给 `GetChatMessageContentAsync` 方法，因为 Kernel 包含有关可用插件的信息。

```cs
var chatCompletionService = kernel.GetRequiredService<IChatCompletionService>();

var chatHistory = new ChatHistory();

chatHistory.AddUserMessage(ask);

var chatCompletionResult = await chatCompletionService.GetChatMessageContentAsync(chatHistory, openAIPromptExecutionSettings, kernel);

Console.WriteLine($"Result: {chatCompletionResult}\n");
Console.WriteLine($"Chat history: {JsonSerializer.Serialize(chatHistory)}\n");
```



### 函数嵌套





### 向量存储

> - https://github.com/microsoft/semantic-kernel/blob/main/dotnet/notebooks/06-vector-stores-and-embeddings.ipynb

- 之前主要将内核视为无状态编排引擎，即文本发送到模型 API 并接收文本。
- 但是如果仅依赖内核参数，最终 prompt 会变得巨大，以至于会遇到模型的 token 限制。所以需要的是一种持久化状态并构建短期和长期内存的方法，以增强更智能的应用程序。

**安装**

- Package `Microsoft.Extensions.VectorData.Abstractions` ，其中包含使用矢量存储所需的所有抽象。

- 然后还需要使用具体数据库连接器的实现。此处使用内存中连接器进行演示 - `Microsoft.SemanticKernel.Connectors.InMemory` 。
  - 支持的连接器：Azure AI Search、Azure CosmosDB、Qdrant、Redis 等。[更多连接器](https://learn.microsoft.com/en-us/semantic-kernel/concepts/vector-store-connectors/out-of-the-box-connectors/)

**定义模型**

- 在抽象中，有三种主要的数据模型属性类型：

  - Key 键

  - Data 数据

  - Vector 向量

- 一般数据模型包含一个 key 属性、多个 data 和 vector 属性
  - 某些连接器可能有限制，例如当仅支持一个 vector property 时。
  - 此外，每个连接器都支持一组不同的属性类型。[连接器支持的属性类型](https://learn.microsoft.com/en-us/semantic-kernel/concepts/vector-store-connectors/out-of-the-box-connectors/)。

- 有两种方法可以定义数据模型
  - 使用特性（声明式方式）
  - 记录定义（命令式方式）
- 以下使用特性定义

```cs
public sealed class Glossary
{
    [VectorStoreRecordKey]
    public ulong Key { get; set; }

    [VectorStoreRecordData]
    public string Term { get; set; }

    [VectorStoreRecordData]
    public string Definition { get; set; }

    [VectorStoreRecordVector(Dimensions: 2560)]
    public ReadOnlyMemory<float> DefinitionEmbedding { get; set; }
}
```

- 在某些情况下无法使用特性添加到现有类上。此时可以定义一个单独的记录定义，其中包含有关属性的所有信息。注意这种情况下，定义的数据模型类仍然是必需的：

```cs
public sealed class GlossaryWithoutAttributes
{
    public ulong Key { get; set; }

    public string Term { get; set; }

    public string Definition { get; set; }

    public ReadOnlyMemory<float> DefinitionEmbedding { get; set; }
}

var recordDefinition = new VectorStoreRecordDefinition()
{
    Properties = new List<VectorStoreRecordProperty>()
    {
        new VectorStoreRecordKeyProperty("Key", typeof(ulong)),
        new VectorStoreRecordDataProperty("Term", typeof(string)),
        new VectorStoreRecordDataProperty("Definition", typeof(string)),
        new VectorStoreRecordVectorProperty("DefinitionEmbedding", typeof(ReadOnlyMemory<float>)) { Dimensions = 1536 }
    }
};
```

**向量存储库和集合创建**

- 定义数据模型后就可以开始在选择的数据库中使用它，涉及到的抽象接口

  - `IVectorStoreRecordCollection<TKey, TRecord>`：表示一个集合。此集合可能存在也可能不存在，并且提供了检查集合是否存在、创建、更新插入、获取和删除记录的方法。该接口继承自 `IVectorizedSearch<TRecord>`，提供向量搜索功能。

  - `IVectorStore`：包含跨向量存储中所有集合的操作，例如 `ListCollectionNames`。它还提供获取 `IVectorStoreRecordCollection<TKey, TRecord>` 实例的功能。

  - 每个连接器都有扩展方法支持依赖注入：`services.AddInMemoryVectorStore()` 或 `services.AddInMemoryVectorStoreRecordCollection("collection-name")` 。

- 以下直接初始化实例使用，集合类似于关系数据库中的表。

```cs
// 创建向量存储库
var vectorStore = new InMemoryVectorStore();
// 通过向量存储库获取集合
var colleciton = vectorStore.GetCollection<ulong, Glossary>("skglossary");
// 通过直接初始化获取集合
var colleciton2 = new InMemoryVectorStoreRecordCollection<ulong, Glossary>("skglossary");
// 确保集合存在于数据库中
await colleciton.CreateCollectionIfNotExistsAsync();
```

**文本向量化存储**

- 首先需要对源数据集合遍历处理生成向量，使用ITextEmbeddingGenerationService的GenerateEmbeddingAsync方法。此时会请求embedding接口。
- 向量化完成后，使用collection的UpsertAsync或UpsertBatchAsync 方法存入向量数据库中。
  - 此操作幂等：如果不存在具有特定键的记录，则会插入该记录。如果它已存在，则将对其进行更新

```cs
// 准备数据
List<Glossary> glossaryEntries =
[
    new Glossary()
    {
        Key = 1,
        Term = "API",
        Definition =
            "Application Programming Interface. A set of rules and specifications that allow software components to communicate and exchange data.",
    },
    new Glossary()
    {
        Key = 2,
        Term = "Connectors",
        Definition =
            "Connectors allow you to integrate with various services provide AI capabilities, including LLM, AudioToText, TextToAudio, Embedding generation, etc.",
    },
    new Glossary()
    {
        Key = 3,
        Term = "RAG",
        Definition =
            "Retrieval Augmented Generation - a term that refers to the process of retrieving additional data to provide as context to an LLM to use when generating a response (completion) to a user's question (prompt).",
    },
];


// 如果想对数据库中的记录执行向量搜索，仅初始化 key 和 data 属性是不够的，还需要生成和初始化向量属性。为此，可以使用 ITextEmbeddingGenerationService。
var textEmbeddingGenerationService =
    kernel.GetRequiredService<ITextEmbeddingGenerationService>();
var tasks = glossaryEntries.Select(e =>
    Task.Run(async () =>
    {
        e.DefinitionEmbedding = await textEmbeddingGenerationService.GenerateEmbeddingAsync(
            e.Definition
        );
    })
);
await Task.WhenAll(tasks);


// 插入到数据库中。可以使用collection的UpsertAsync或UpsertBatchAsync 方法。此操作幂等 - 如果不存在具有特定键的记录，则会插入该记录。如果它已存在，则将对其进行更新
await foreach (var key in colleciton.UpsertBatchAsync(glossaryEntries))
{
    Console.WriteLine(key);
}
```

**查询向量数据**

- 使用 collection.GetAsync 或 GetBatchAsync按键获取记录。支持GetRecordOptions作为参数指定是否要在响应中包含向量属性。
  - 因为 vector 维度值可能很高，不推荐从数据库中获取。所以 GetRecordOptions.IncludeVectors = false 是默认值。（这里为了测试所以需要看到向量）

```cs
var options = new GetRecordOptions() { IncludeVectors = true };
await foreach (var record in colleciton.GetBatchAsync(keys: [1, 2, 3], options))
{
    System.Console.WriteLine(record.Definition);
    await record.SerializeObjectToFile();
}
```

**搜索向量**

- 查询字符串再调用embedding服务生成搜索向量。
- 然后使用IVectorStoreRecordCollection的VectorizedSearchAsync方法搜索，其接受 VectorSearchOptions 作为参数允许配置向量搜索操作
  - 指定要返回的最大记录数、返回结果之前要跳过的结果数、在执行向量搜索之前要使用的搜索过滤器等。

```cs
// 搜索，，
var searchString = "I want to learn more about Connectors";
var searchVector = await textEmbeddingGenerationService.GenerateEmbeddingAsync(
    searchString
);

var searchResult = await colleciton.VectorizedSearchAsync(searchVector);
await foreach (var result in searchResult.Results)
{
    Console.WriteLine($"Search score: {result.Score}");
    Console.WriteLine($"Key: {result.Record.Key}");
    Console.WriteLine($"Term: {result.Record.Term}");
    Console.WriteLine($"Definition: {result.Record.Definition}");
    Console.WriteLine("=========");
}
```

- 结果

```
Search score: 0.785374104976654
Key: 2
Term: Connectors
Definition: Connectors allow you to integrate with various services provide AI capabilities, including LLM, AudioToText, TextToAudio, Embedding generation, etc.
=========
Search score: 0.7311795353889465
Key: 1
Term: API
Definition: Application Programming Interface. A set of rules and specifications that allow software components to communicate and exchange data.
=========
Search score: 0.6290566325187683
Key: 3
Term: RAG
Definition: Retrieval Augmented Generation - a term that refers to the process of retrieving additional data to provide as context to an LLM to use when generating a response (completion) to a user's question (prompt).
=========
```































